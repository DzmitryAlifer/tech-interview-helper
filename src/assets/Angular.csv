topic,words,answer
Lifecycle hooks,lifecycle hook hooks,'ngOnChanges' - on value of a data bound property change. 'ngOnInit' - called once on initialization of the directive/component sets and displays component input properties. 'ngDoCheck' - called during every change detection run. 'ngAfterContentInit' - called once right after ngDoCheck when ng-content pushed external content into the component's view. 'ngAfterContentChecked' - called after Angular checks the ng-content projected into the component. 'ngAfterViewInit' - called after Angular initializes the component's views and child views. 'ngAfterViewChecked' - called after Angular checks the component's views and child views. 'ngOnDestroy' - called before Angular destroys the directive/component.
constructor vs ngOnInit,constructor,'constructor' - default TS method which is normally used for the initialization purpose; mostly used only for DI setup. 'ngOnInit' - specific to Angular especially used to define Angular bindings. Even though constructor getting called first it is preferred to move all of Angular bindings to it. Important note that '@Input' values are not accessible in constructor.
Data binding,binding,Core concept that defines the communication between component and template. Data binding ways: 1. From component to template: interpolation (<p>{{name}}</p>) and property binding ([property]=”value”) 2. From template to component (event binding): <button (click)="logout()"></button> 3. Two-way binding: [(ngModel)]=”value”
Metadata. Decorators.,metadata decorator decorators,Metadata is the way to configure the expected behavior of the class. The metadata is represented by decorators: 1. Class decorators (@NgModule @Component) 2. Property decorators (@Input @Output) 3. Method decorators (@Input @HostListener) 4. Parameter decorators (@Inject)
Dependency injection,dependency injection,DI in Angular is an embedded mechanism that allows classes to asks for dependencies from external sources rather than creating them itself. '@Injectable' decorator specifies that Angular can use this class in the DI system.
Custom pipes,pipe pipes,Apart from built-in pipes you can write your own custom pipe. A pipe is a class decorated with @Pipe decorator that implements the PipeTransform interface's transform method that accepts an input value and params and returns the output value. The defined pipe name can be used within template expressions.
Pure vs impure pipes,pure impure pipe pipes,Pure pipe is only called when Angular detects a change in the value or params passed to a pipe. Pipes are pure by default. Impure pipe (controlled by pure:false) is called for every change detection cycle (very often) no matter whether value or params changes. Impure pipes might be needed when the input was changed by property (not by reference). In this case pure pipe won't detect it. Although impure pipes are being called very often so it may harm the performanse. So it's not recommended to use the for filtering operations.
trackBy,track,The main purpose of using 'ngFor' with 'trackBy' option is performance optimization. You can help Angular to track which items added or removed by providing a 'trackBy' function which takes the index and the current item as args and needs to return the unique identifier for this item.
@ViewChild,view child children,@ViewChild is a template querying mechanism that is local to the component. It is being used to inject a reference to: 1. own template HTML element: @ViewChild('title') title: ElementRef 2. component or directive: @ViewChild(ChildComponent) childComponent: ChildComponent 3. directive (maybe one of many on this element): @ViewChild('inputElement' {read: MyDirective}) myDirective: MyDirective. '@ViewChild' injected value is not immediately available at component construction time. Angular will fill in this property automatically but only after the view initialization is completed ('ngAfterViewInit'). @ViewChild's static (defaults to false) property is being used for indicating whether the reference to be instantiated before (true) or after (false) change detection. True is for creating embedded views (like charts) on the fly.
Module,module modules,@NgModule metadata is used to tell the compiler what components to be compiled for this module and how to link this module with other modules.
Bootstrapping module,bootstrap bootstrapping module,Bootstrapping module is a single root module that is being used for launching the app. It is commonly known as AppModule. It imports the BrowserModule. In its metadata it contains bootstrapping component: 'bootstrap: [AppComponent]'. Bootstrapping module is being bootstrapped from the app entry point (src/main.ts) like this: 'platformBrowserDynamic().bootstrapModule(AppModule)'.
Feature module,feature module,Used for the purpose of organizing code. They import 'CommonModule' that provides common directives as 'ngIf' and 'ngFor'.
Lazy-loaded module,lazy loaded module,By default modules are eagerly loaded. To keep the initial bundle size smaller some of modules can be made lazy-loaded. This way the app will be loaded by smaller chunks instead of one big bundle. To lazy load module use 'loadChildren' (instead of 'component') in 'AppRoutingModule' routes configuration: 'loadChildren: () => import('./items/items.module').then(m => m.ItemsModule)'
Resolvers and guards,resolver resolvers guard guards,Resolver is a data provider and it is about authorized access to the data for the component before the router starts navigation (runs before guard). Implements interface 'Resolve' (with method 'resolve'). Guard is about authorized access to the route with or without module loading. Implements interface like 'CanActivate' (with method 'canActivate') or 'CanLoad' (with method 'canLoad').
canActivate vs canLoad guards,activate load guard guards,'canActivate' - decides if a route can be activated; it may not be the best way for feature modules that are lazy loaded as this guard will always load the module in memory even if the guard returned false which means user is not authorized (security issue - it can be seen in Sources tab). 'canLoad' - for lazy-loaded modules; decides if a module can be loaded lazily.
Provider,provider providers,Provider is an instruction to DI system on how to obtain a value for a dependency. Ways to declare provider: 1. '@Injectable({providedIn: 'root'})' - service is available throughout the app (allows keeping the service as a singleton) 2. '@Injectable({providedIn: UserModule})' - service is available only if UserModule is imported 3. '@NgModule({providers: [UserService]})' - service is available only if UserModule is imported (same as previous). Sharing services via modules is not recommended since importing module will result each time with a new service instance instead of recommended singletone.
Router outlet,router outlet,'RouterOutlet' is a directive from the router library and it acts as a placeholder that marks the spot in the template where the router should display the components for that outlet. Router outlet is used like a component: '<router-outlet></router-outlet>'.
Router link,router link,'RouterLink' is a directive on the anchor tag that give the router control. 'RouterLinkActive' is a directive that toggles css classes for active 'RouterLink' bindings based on the current 'RouterState'. '<a routerLink="/todosList" routerLinkActive="active">List of todos</a>'
Router state,router state,'RouterState' is a tree of activated routes. Every node in this tree knows about the "consumed" URL segments - the extracted parameters - and the resolved data. You can access the current 'RouterState' from anywhere in the application using the Router service and the 'routerState' property.
Router events,router events,During each navigation the Router emits navigation events through 'Router.events' property allowing you to track the lifecycle of the route. The sequence of router events: NavigationStart RouteConfigLoadStart RouteConfigLoadEnd RoutesRecognized GuardsCheckStart ChildActivationStart ActivationStart GuardsCheckEnd ResolveStart ResolveEnd ActivationEnd ChildActivationEnd NavigationEnd NavigationCancel NavigationError Scroll
Activated route,activate activated route root,'ActivatedRoute' contains the information about a route associated with a component loaded in an outlet. It provides access to path and params (as observables).
Routes config,route root routes roots config configuration,A router must be configured with a list of route definitions: 'const appRoutes: Routes = [{path: '/...'} ...]'. This config array should be included into AppModule's imports array: 'imports: [RouterModule.forRoot(appRoutes) ...]'.
Route properties,route root props properties,'path' - path to match. Default is path: '/'; path: ' ' - for router entry component; path: '**' - for any unmatched (for page not found). 'pathMatch' - full or prefix. 'component' - component to instantiate. 'redirectTo' - redirection URL. 'children' - array of child routes. 'loadChildren' - lazy-loaded child routes. 'data' - additional developer-defined data provided to the component via ActivatedRoute. 'canActivate' - array of guards for preventing unauthorized access to the route. 'canLoad' - array of guards for preventing unauthorized loading of lazy modules. 'resolve' - contains resolvers used for retreiving the data. 'runGuardsAndResolvers' - defines when guards and resolvers should run (paramsOrQueryParamsChange or always).
JIT compilation,just time compilation compiler,Just-in-Time - compiles app in the browser at runtime. It is the default when you run the ng build or ng serve.
AOT compilation,ahead time compilation compiler,Ahead-of-Time - compiles app at build time. 'ng build --aot' or 'ng serve --aot' or 'ng build --prod'. Can be enabled in tsconfig.json. Advantages: 1. faster rendering - browser downloads a pre-compiled app version so it can render the application immediately without compiling 2. doesn't requre to download compiler 3. less async requests - it compiles HTML and CSS into JS which eliminates separate ajax requests to templates and styles 4. better security - it compiles HTML and components into JS so there won't be any injection attacks 5. detects template errors earlier. AOT compilation phases: 1. Code analysis. 2. Code generation. 3. Template validation.
Change detection,change detection,CD - process of checking whether the app state has changed and if any DOM needs to be updated. Angular walks through components from top to bottom looking for changes. Way to trigger CD: 1. 'changeDetectorRef.detectChanges()' - runs CD immediately from the current component down through its descendants 2. 'applicationRef.tick()' - triggers CD for the full component tree 3. 'ngZone.run(callback)'. We can run CD repeatedly with scheduled interval: 'cdRef.detach(); setTimeout(() -> { cdRef.markForCheck(); } 5000);'
detectChanges vs markForCheck vs detach,detect changes mark check detach,'detectChanges()' - runs CD immediately from the current component down through its descendants. 'markForCheck()' - does not run CD but mark component's ancestors as needing to run CD so next time CD runs anywhere it will run also for those components which were marked. In most cases 'markForCheck()' is preferable because it reduces the number of times CD is called. But if it's critical to update the view at that moment when the state is changed or when you are changing the state of the component that has more ancestors than descendants then 'detectChanges()' is the right choise. 'detach()' - detaches view from CD tree.
CD strategy OnPush,change detection strategy push,Triggers CD when component property link has changed. CD won't be triggered if just one of the properties has been changed. E.g. it needs immutable objects. It works the similar way as 'detach()' - it changes detection mode from default 'CheckAlways' to 'CheckOnce'.
ReactiveFormsModule vs FormsModule,form forms reactive,'FormsModule' - implements template-driven forms - model-driven forms where you write the logic validations controls etc in the template part of the code using directives. They are suitable for simple scenarios and have minimal component code and uses two-way binding with '[(ngModel)]' syntax and hard testable. 'ReactiveFormsModule' - implements a model-driven approach for creating forms in a reactive style (form inputs changes over time). These are built around observable streams where form inputs and values are provided as streams of input values. Code is mostly in component. Easily testable.
Form validations: sync vs async,form forms validator validators validation validations,Sync validators are being used for the simple operations without calling BE. Otherwise - use async ones.
ng-content,content,'ng-content' is used to insert the content dynamically inside the component that helps to increase component reusability.
Test harness,harness,A component harness is a testing API around an Angular directive or component to make tests simpler by hiding implementation details from test suites. This can be shared between tests. The idea for component harness comes from the PageObject pattern commonly used for integration testing.
Bazel,bazel,Bazel is a powerful build tool developed and massively used by Google and it can keep track of the dependencies between different packages and build targets. In Angular 8 you can build your CLI application with Bazel. Benefits: 1. both BE and FE can be built with Bazel 2. supports incremental build and tests
Tree shaking,tree shaking,TS - step in build process that removes unused code so the application becomes smaller. It can be visualised as shaking a physical tree causing dead branches and leaves to fall off. One of the primary ways Angular looks for code to shake is by import paths.
Ivy,ivy eevy eevee,Ivy is a new rendering engine for Angular. You can choose to opt in a preview version of Ivy from Angular version 8. It can be enabled in 'angularCompilerOptions' of 'tsconfig'. Since Angular 9 Ivy is switched on by default. Ivy benefits: 1. generated code that is easier to read and debug at runtime 2. faster re-build time 3. faster AOT compilation 4. improved payload size 5. improved template type checking
Zone,zone,Zone - concept that provides execution context that persists across async tasks. Zone allows to customize CD (f.e. to prevent a mousemove or scroll event to trigger CD). While Zone.js can monitor all the states of sync and async operations Angular additionally provides a service called NgZone. This service creates a zone named angular to automatically trigger CD when sync or async function is executed. NgZone service provides a 'run()' method that allows you to execute a function inside Angular zone. This function is used to execute third party APIs which are not handled by Zone and trigger CD automatically at the correct time. Whereas 'runOutsideAngular()' method is used when you don't want to trigger CD. Zone is being imported in 'polyfills.ts'. It can be disabled by removing that import. If you disable Zone you will need to trigger all CD by yourself.
Zone lifecycle hooks,zone,'onScheduleTask' - when new async task is scheduled (f.e. when setTimeout() is called). 'onInvokeTask' - when async task is about to execute (f.e. when the callback of setTimeout() is about to execute). 'onHasTask' - when task status changes from stable (no tasks in the zone) to unstable(a new task is scheduled in the zone) or visa versa. 'onInvoke' - when synchronous function is going to execute.
Service workers,worker workers,SW - script that runs in web browser and manages caching for app. Works with HTTPS not HTTP. Using SW to provide precaching lets you intercept network requests and deliver responses directly from a local cache instead of retrieving them from the network. With the help of SW it is possible to make the app restored from cache once the user closes and then re-opens browser tab.