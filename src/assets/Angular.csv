topic,words,answer
Angular,angular,<i>Angular</i> - TypeScript-based free and open-source web abb framework owned and developed by Google. Nowadays it's not even just a framework - it's rather a platform because we have additional tools and plugins and libs and design concepts which are being widely used along with Angular (RxJs; NgRx; Angular Material; linter plugins).<br><br>Advantages:<br>- <i>MVVM architecture</i> (separation of model and view and conversion of model to viewmodel)<br>- <i>dependency injection</i> (no need to know about the inner instantiation details of the services that we use in components)<br>- modules (being used for exposing multiple components at once which gives great scalability)<br>- <i>incremental DOM</i> (the DOM is getting updated in-place when data changes - memory efficient)<br>- <i>test harness</i> (a very cool approach in unit-testing)
Model–View–ViewModel (MVVM),model view,<i>MVVM</i> - architectural pattern in that separates GUI (view) from the business logic and back-end logic (the model). It makes <i>View</i> not dependent upon any specific <i>Model</i> platform. The <i>ViewModel</i> of MVVM is a model converter which is responsible for converting the model data objects into the UI-dictated model (it can be easily presented on UI). <i>ViewModel</i> is more model than view and handles most (if not all) of the view's display logic.
Lifecycle hooks,life cycle cycles lifecycle hook hooks hoax hawk hawks,<i>ngOnChanges</i> - on value of a data bound property change. <br><br><i>ngOnInit</i> - called once on initialization of the directive/component sets and displays component input properties. <br><br><i>ngDoCheck</i> - called during every change detection run. <br><br><i>ngAfterContentInit</i> - called once right after <i>ngDoCheck</i> when <i>ng-content</i> pushed external content into the component's view. <br><br><i>ngAfterContentChecked</i> - called after Angular checks the <i>ng-content</i> projected into the component. <br><br><i>ngAfterViewInit</i> - called after Angular initializes the component's views and child views. <br><br><i>ngAfterViewChecked</i> - called after Angular checks the component's views and child views. <br><br><i>ngOnDestroy</i> - called before Angular destroys the directive/component.
constructor vs ngOnInit,constructor instructor,<i>constructor</i> - default TS method which is normally used for the initialization purpose; mostly used only for DI setup. <br><br><i>ngOnInit</i> - specific to Angular especially used to define Angular bindings. Even though constructor getting called first it is preferred to move all of Angular bindings to it. <br><br><i>@Input</i> values are not accessible in <i>constructor</i>.
Data binding,binding interpolation two-way,Core concept that defines the communication between component and template. <br><br>Data binding ways: <br><br>1. From component to template - <i>interpolation</i>: <i> {{name}}</i><br> 2. From component to template - <i>property binding</i>: <i>[property]='value'</i> <br>3. From template to component - <i>event binding</i>: <i>(click)='logout()'</i> <br>4. <i>Two-way binding</i>: <i>[(ngModel)]='value'</i>
Template statement,template statement statements,Properties or methods used in HTML for responding to user events.<br><i>< button (click)='close()' >Close</ button ></i>
Metadata. Decorators.,metadata decorator decorators,<i>Metadata</i> is the way to configure the expected behavior of the class.<br><br>The metadata is represented by decorators:<br>1. Class decorators (<i>@NgModule @Component</i>)<br>2. Property decorators (<i>@Input @Output</i>)<br>3. Method decorators (<i>@Input @HostListener</i>)<br>4. Parameter decorators (<i>@Inject</i>)
Dependency injection,dependency injection traction,DI - design pattern in which consumer (class/component/object) receives references to providers that it depends on (a form of <i>inversion of control</i>). DI separates the concerns of constructing objects and using them which leads to loosely coupling. It's a good practice when consumer doesn't know how to construct those provider-services.<br><br>DI in Angular is an embedded mechanism that allows classes to ask for dependencies from external sources rather than creating them itself. <i>@Injectable</i> decorator specifies that Angular can use this class in the DI system.
Inversion of control,inversion control dependency injection traction,<i>IoC</i> inverts the flow of control as compared to traditional control flow. In <i>IoC</i> your code receives the flow of control from a framework. A software architecture with this design inverts control as compared to traditional procedural programming. in traditional programming your code is responsible for such generic tasks like instantiation of dependencies. But with <i>IoC</i> it is the framework that calls your code to take care of those instantiations.<br><br><i>IoC</i> follows these rules:<br>1. Separate <i>what-to-do</i> part from <i>when-to-do</i> part.<br>2. Ensure that when part knows as little as possible about what part; and vice versa.
Provider. Injectable.,provider providers injectable service reminder reliable,Provider is an instruction to DI system on how to obtain a value for a dependency. <br><br>Ways to declare provider: <br>1. <i>@Injectable({providedIn: 'root'})</i> - service is available throughout the app (allows keeping the service as a singleton) <br>2. <i>@Injectable({providedIn: UserModule})</i> - service is available only if <i>UserModule</i> is imported <br>3. <i>@NgModule({providers: [UserService]})</i> - service is available only if <i>UserModule</i> is imported (same as previous). <br><br>Sharing services via modules is not recommended since importing module will result each time with a new service instance instead of recommended singletone.
Custom pipes,pipe pipes fight piper,Apart from built-in pipes you can write your own custom pipe. A pipe is a class decorated with <i>@Pipe</i> decorator that implements the <i>PipeTransform</i> interface's transform method that accepts an input value and params and returns the output value. The defined pipe name can be used within template expressions.
Pipes,pipe pipes,<i>Pipe</i> - simple function that accepts an input value and returns a transformed value. In terms of <i>MVVM</i> architecture it is one more small layer between <i>ModelView</i> and <i>View</i>. Angular supports several built-in pipes. However you can also create custom pipes that cater to your needs.
Pure vs impure pipes,pure impure pipe pipes fight piper,<i>Pure</i> pipe is only called when Angular detects a change in the value or params passed to a pipe. Pure pipes are usually written as pure functions. Pipes are pure by default. <br><br><i>Impure</i> pipe (controlled by <i>pure:false</i>) is called for every CD cycle (very often) no matter whether value or params changes. <br><br><i>Impure</i> pipes might be needed when the input was changed by property (not by reference). In this case <i>pure</i> pipe won't detect it. Although <i>impure</i> pipes are being called very often so it may harm the performanse.
trackBy,track trend dragon ball by buy bye trek bike,The main purpose of using <i>*ngFor</i> with <i>trackBy</i> option is performance optimization. You can help Angular to track which items added or removed by providing a <i>trackBy</i> function which takes the index and the current item as args and needs to return the unique identifier for this item.
@ViewChild,view child viewchild children,<i>@ViewChild</i> is a template querying mechanism that is local to the component. It injects a reference to: <br>1. own template HTML element: <i>@ViewChild('title') title: ElementRef</i> <br>2. component or directive: <i>@ViewChild(ChildComponent) childComponent: ChildComponent</i> <br>3. directive (maybe one of many on this element): <i>@ViewChild('inputElement' {read: MyDirective}) myDirective: MyDirective</i>. <br><br><i>@ViewChild</i> injected value is not immediately available at component construction time. Angular will fill in this property automatically but only after the view initialization is completed (<i>ngAfterViewInit</i>). <br><br><i>@ViewChild</i>'s static (defaults to <i>false</i>) property is being used for indicating whether the reference to be instantiated before (true) or after (false) change detection. <i>True</i> is for creating embedded views (like charts) on the fly.
@HostListener,host post listener listen,Decorator that declares a DOM event to listen for and provides a handler method to run when that event occurs in host element.<br><br><i>@HostListener('window:keydown.enter'; ['$event']) handleKeyDown(event: KeyboardEvent) {...}</i>
@HostBinding,host post binding bindings,Declares a host property binding. Angular automatically checks host property bindings during CD. If a binding changes it will update the host element of the directive.<br><br><i>@HostBinding('style.color') color!: string;</i>
Module,module modules model mondo moodle madill mojo,<i>@NgModule</i> metadata is used to tell the compiler what components to be compiled for this module and how to link this module with other modules.
Bootstrapping module,bootstrap bootstrapping boot strapping module modules model mondo moodle madill mojo,Bootstrapping module is a single root module that is being used for launching the app. It is commonly known as <i>AppModule</i>. It imports the <i>BrowserModule</i>.<br><br>In its metadata it contains bootstrapping component: <i>bootstrap: [AppComponent]</i> - root component that Angular creates and inserts into the <i>index.html</i> host web page.<br><br>Bootstrapping module is being bootstrapped from the app entry point (<i>src/main.ts</i>) like this: <i>platformBrowserDynamic().bootstrapModule(AppModule)</i>.
Feature module,feature future beecham module modules model mondo moodle madill mojo,Used for the purpose of organizing code. Import <i>CommonModule</i> that provides common directives as <i>*ngIf</i> and <i>*ngFor</i>.
Lazy-loaded module,lazy loaded loading laud loud lauding module modules model mondo moodle madill mojo,By default modules are eagerly loaded. To keep the initial bundle size smaller some of modules can be made lazy-loaded. This way the app will be loaded by smaller chunks instead of one big bundle. <br><br>To lazy load module use <i>loadChildren</i> (instead of <i>component</i>) in <i>AppRoutingModule</i> routes configuration: <br><i>loadChildren: () => import('./items/items.module').then(m => m.ItemsModule)</i>
Resolvers and guards,resolver resolvers resolve guard guards,<i>Resolver</i> is a data provider and it is about authorized access to the data for the component before the router starts navigation (runs before <i>guard</i>). Implements interface <i>Resolve</i> (with method <i>resolve</>). <br><br><i>Guard</i> is about authorized access to the route with or without module loading. Implements interfaces like <i>CanActivate</i> (with method <i>canActivate</i>) or <i>CanLoad</i> (with method <i>canLoad</i>).
canActivate vs canLoad guards,can activate connect connectivity loaded loading loaded load loads loud laud guard guards handload handloads,<i>canActivate</i> - decides if a route can be activated; it may not be the best way for feature modules that are lazy loaded as this guard will always load the module in memory even if the guard returned <i>false</i> which means user is not authorized (security issue - it can be seen in Sources tab). <br><br><i>canLoad</i> - for lazy-loaded modules; decides if a module can be loaded lazily.
Router outlet,router realtor powder roads outlet outlets,<i>RouterOutlet</i> is a directive from the router library and it acts as a placeholder that marks the spot in the template where the router should display the components for that outlet. Router outlet is used like a component: <i><router-outlet></router-outlet></i>.
Router link,router realtor powder roads link routerlink,<i>RouterLink</i> is a directive on the anchor tag that give the router control. <br><br><i>RouterLinkActive</i> is a directive that toggles css classes for active <i>RouterLink</i> bindings based on the current <i>RouterState</i>.
Router state,router realtor powder roads state,<i>RouterState</i> is a tree of activated routes. Every node in this tree knows about the <i>consumed</i> URL segments - the extracted parameters - and the resolved data. You can access the current <i>RouterState</i> from anywhere in the application using the <i>Router</i> service and the <i>routerState</i> property.
Router events,router realtor powder roads rota event events,During each navigation the <i>Router</i> emits navigation events through <i>Router.events</i> property allowing you to track the lifecycle of the route. <br><br>The sequence of router events: <i>NavigationStart RouteConfigLoadStart RouteConfigLoadEnd RoutesRecognized GuardsCheckStart ChildActivationStart ActivationStart GuardsCheckEnd ResolveStart ResolveEnd ActivationEnd ChildActivationEnd NavigationEnd NavigationCancel NavigationError Scroll</i>
Activated route,activate activated route root road throat,<i><a href='https://angular.io/api/router/ActivatedRoute'>ActivatedRoute</a></i> contains the information about a route associated with a component loaded in an outlet. After injecting to <i>constructor</i> it provides access to path and params (as observables).<br><br>Some of its properties:<br><i>url: Observable< UrlSegment[] ><br>params: Observable< Params ><br>QueryParams: Observable< Params ><br>data: Observable< Data ></i>
Routes config,route root routes roots road ralph's rhodes config configure confused configuration comfy,A router must be configured with a list of route definitions: <br><i>const appRoutes: Routes = [{path: '/...'} ...]</i>. <br><br>This config array should be included into <i>AppModule</i>'s imports array: <br><i>imports: [RouterModule.forRoot(appRoutes) ...]</i>.
Route properties,route root props properties,<i>path</i> - path to match. Default is <i>path: '/'</i>; <i>path: ' '</i> - for router entry component; <i>path: '**'</i> - for any unmatched (for page not found). <br><i>pathMatch</i> - full or prefix. <br><i>component</i> - component to instantiate. <br><i>redirectTo</i> - redirection URL. <br><i>children</i> - array of child routes. <br><i>loadChildren</i> - lazy-loaded child routes. <br><i>data</i> - additional developer-defined data provided to the component via ActivatedRoute. <br><i>canActivate</i> - array of guards for preventing unauthorized access to the route. <br><i>canLoad</i> - array of guards for preventing unauthorized loading of lazy modules. <br><i>resolve</i> - contains resolvers used for retreiving the data. <br><i>runGuardsAndResolvers</i> - defines when guards and resolvers should run (<i>paramsOrQueryParamsChange</i> or <i>always</i>).
Angular compiler,compilation completion compiler compile,Angular compiler's (ngc) objectives:<br>1. Compiles Angular decorators including components and their templates.<br>2. Applies TypeScript’s type-checking rules to component templates.<br>3. Re-compiles quickly when the developer makes a change.
JIT compilation,just time compilation completion compiler compile,<i>Just-in-Time</i> - compiles app in the browser at runtime. It is the default when you run the ng build or ng serve.
AOT compilation,ahead time compilation completion compiler compile,<i>Ahead-of-Time</i> - compiles app at build time. <i>ng build --aot</i> or <i>ng serve --aot</i> or <i>ng build --prod</i>. Can be enabled in <i>tsconfig.json</i>. <br><br>Advantages: <br>1. faster rendering - browser downloads a pre-compiled app version so it can render the application immediately without compiling <br>2. doesn't requre to download compiler <br>3. less async requests - it compiles HTML and CSS into JS which eliminates separate ajax requests to templates and styles <br>4. better security - it compiles HTML and components into JS so there won't be any injection attacks <br>5. detects template errors earlier. <br><br>AOT compilation phases: <br>1. Code analysis. <br>2. Code generation. <br>3. Template validation.
Change detection,change changes detection detect mark check butcher detach,CD - process of checking whether the app state has changed and if any DOM needs to be updated. Angular walks through components from top to bottom looking for changes. <br><br>Way to trigger CD: <br>1. <i>changeDetectorRef.detectChanges()</i> - runs CD immediately from the current component down through its descendants <br>2. <i>applicationRef.tick()</i> - triggers CD for the full component tree <br>3. <i>ngZone.run(callback)</i>. <br><br>We can run CD repeatedly with scheduled interval: <br><i>cdRef.detach(); setTimeout(() -> { cdRef.markForCheck(); } 5000);</i>
detectChanges vs markForCheck vs detach,detect detection change changes mark check butcher detach,<i>detectChanges()</i> - runs CD immediately from the current component down through its descendants. <br><br><i>markForCheck()</i> - does not run CD but mark component's ancestors as needing to run CD so next time CD runs anywhere it will run also for those components which were marked. <br><br>In most cases <i>markForCheck()</i> is preferable because it reduces the number of times CD is called. But if it's critical to update the view at that moment when the state is changed or when you are changing the state of the component that has more ancestors than descendants then <i>detectChanges()</i> is the right choise. <br><br><i>detach()</i> - detaches view from CD tree.
CD strategy OnPush,change detection strategy push porsche,Triggers CD when component property link has changed. CD won't be triggered if just one of the properties has been changed. E.g. it needs immutable objects. <br><br>It works the similar way as <i>detach()</i> - it changes detection mode from default <i>CheckAlways</i> to <i>CheckOnce</i>.<br><br><i>OnPush</i> CD gets triggered in a couple of situations other than changes in component <i>@Input()</i> references:<br>- if component's event handler gets triggered<br>- if observable linked to the template via the <i>async</i> pipe emits a new value<br><br> So if we remember to subscribe to any observables as much as possible using the <i>async</i> pipe in template we get a couple of advantages:<br>- we will run into much less CD cycles using <i>OnPush</i><br>- we will make it much easier to switch from the default CD strategy to <i>OnPush</i> later if we need to<br>- immutable data and <i>@Input()</i> reference comparison is not the only way to achieve a high performant UI with <i>OnPush</i>: the reactive approach is also an option to use OnPush effectively
View encapsulation,view encapsulation,Defines whether template and styles defined within the component can affect the whole app or vice versa. Strategies:<br>- <i>emulated</i> (default and recommended): main HTML styles propagate to the component<br>- <i>native</i>: main HTML styles do not propagate to the component<br>- <i>none</i>: component styles propagate back to the main HTML and are visible to all components on the page
ReactiveFormsModule vs FormsModule,form forms reactive,<i>FormsModule</i> - implements template-driven forms - model-driven forms where you write the logic validations controls etc in the template part of the code using directives. They are suitable for simple scenarios and have minimal component code and uses two-way binding with <i>[(ngModel)]</i> syntax and hard testable. <br><br><i>ReactiveFormsModule</i> - implements a model-driven approach for creating forms in a reactive style (form inputs changes over time). These are built around observable streams where form inputs and values are provided as streams of input values. Code is mostly in component. Easily testable.
Form validations: sync vs async,form forms validator validators validation validations,Sync validators are being used for the simple operations without calling BE. Otherwise - use async ones.
ng-content,content,<i>ng-content</i> is used to insert the content dynamically inside the component that helps to increase component reusability.
Test harness,harness,<i>Component harness</i> is a testing API around an Angular directive or component to make tests simpler by hiding implementation details from test suites. This can be shared between tests. The idea for component harness comes from the <i>PageObject</i> pattern commonly used for integration testing.
Bazel,bazel basel basil bottle beethoven,Bazel is a powerful build tool developed and massively used by Google and it can keep track of the dependencies between different packages and build targets. In Angular 8 you can build your CLI application with Bazel. <br><br>Benefits: <br>1. both BE and FE can be built with Bazel <br>2. supports incremental build and tests
Tree shaking,tree free shaking,TS - step in build process that removes unused code so the application becomes smaller. It can be visualised as shaking a physical tree causing dead branches and leaves to fall off. One of the primary ways Angular looks for code to shake is by import paths.<br><br>Angular supports tree-shakable providers via @Injectable({providedIn: 'root'}). In general all services should be tree-shakable; all tree-shakable providers should be bound to <i>'root'</i> and tree-shakable services should not be provided in any <i>@NgModule</i>.<br><br>Benefits of tree-shakable providers:<br>- enabling Angular to remove unused service code when compiling the build<br>- if used in a <i>lazy-loaded</i> module moving the code for the service out of the base module to a later module thereby reducing the initial load size<br>- ensuring the service will be instantiated as a global singleton even if the app uses lazy loading
Ivy,ivy eevy eevee evie easy tv,Ivy is a new rendering engine for Angular. It can be enabled in <i>angularCompilerOptions</i> of <i>tsconfig</i>. Since Angular 9 Ivy is switched on by default. Since Angular 15 Ivy is one only rendering engine.<br><br>Ivy benefits: <br>1. generated code that is easier to read and debug at runtime <br>2. faster re-build time <br>3. faster AOT compilation <br>4. improved payload size <br>5. improved template type checking
Zone,zone loan lawn,<i>Zone</i> - concept that provides execution context that persists across async tasks. Zone allows to customize CD (f.e. to prevent a mousemove or scroll event to trigger CD). <br><br>While <i>Zone.js</i> can monitor all the states of sync and async operations Angular additionally provides a service called <i>NgZone</i>. This service creates a zone named angular to automatically trigger CD when sync or async function is executed. <i>NgZone</i> service provides a <i>run()</i> method that allows you to execute a function inside Angular zone. This function is used to execute third party APIs which are not handled by Zone and trigger CD automatically at the correct time. Whereas <i>runOutsideAngular()</i> method is used when you don't want to trigger CD. <br><br><i>Zone</i> is being imported in <i>polyfills.ts</i>. It can be disabled by removing that import. If you disable <i>Zone</i> you will need to trigger all CD by yourself.
Zone lifecycle hooks,zone loan lawn,<i>onScheduleTask</i> - when new async task is scheduled (f.e. when <i>setTimeout()</i> is called).<br><br><i>onInvokeTask</i> - when async task is about to execute (f.e. when the callback of <i>setTimeout()</i> is about to execute).<br><br><i>onHasTask</i> - when task status changes from stable (no tasks in the zone) to unstable(a new task is scheduled in the zone) or visa versa.<br><br><i>onInvoke</i> - when synchronous function is going to execute.
Incremental DOM,incremental dom dome,<i>Incremental DOM</i> - mechanism for building up DOM and updating it in-place when data changes. It is primarily intended as a compilation target for templating languages. Unlike <i>Virtual DOM</i> (used f.e. by React) no intermediate tree is created (the existing tree is mutated in-place). This approach significantly reduces <i>heap</i> memory allocation for the DOM update operations.
