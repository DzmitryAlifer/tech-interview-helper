topic,words,answer
OOP,oop oriented programming principle principles encapsulation abstraction inheritance polymorhysm association composition aggregation,<i>Encapsulation</i> (hidden implementation) - each object maintains a private state inside its class; other objects can not access this state directly - they can only invoke a list of public functions.<br><br><i>Abstraction</i> (encapsulation extension) - class should only represent information that is relevant to the problem's context; also it's about the extraction of some context which is shared between multiple classes and moving it to the parent class (such parent class is called an <i>abstract</i>) class.<br><br><i>Inheritance</i> - ability to create child classes based on parent classes.<br><br><i>Polymorphism</i> - means 'many forms' and it's the ability of one method to return different values according to certain conditions Example: same function with different signatures.<br><br><i>Association</i> - relation between two separate classes which establishes through their objects. It can be <i>one-to-one; one-to-many; many-to-one; many-to-many</i>. In OOP object communicates to another object to use functionality provided by that object.<br><br><i>Aggregation</i> (form of <i>Association</i>)- establishes one-way relation (<i>has-A</i> form); both the entries can survive individually e.g. ending one entity will not affect the other entity.<br><br><i>Composition</i> (form of <i>Aggregation</i>) - two entities are highly dependent on each other (<i>part-of</i> relationship).
SOLID,solid principle principles,<i>Single Responsibility</i> - class/component should have only one responsibility.<br><br><i>Open/Closed</i> - classes should be open for extension but closed for modification. E.g. we should avoid modifying existing code and causing potential new bugs.<br><br><i>Liskov Substitution</i> - extends open/closed principle; if class A is subtype of class B we should be able to replace A with B without disrupting the behavior of our program.<br><br><i>Interface Segregation</i> - larger interfaces should be split into smaller ones so we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.<br><br><i>Dependency Inversion</i> refers to decoupling of software modules e.g. instead of high-level modules depending on low-level modules both will depend on abstractions. Great example here is <i>Dependency Injection</i> pattern which allows to use dependencies without the knowledge about their instantiations.
Design patterns,design pattern patterns,<i>Singleton</i> - only one instance of class is possible.<br><i>Factory</i> - method that creates objects of type.<br><br><i>Iterator</i> - providing an API to loop over and navigate around a complex custom data structure.<br><br><i>Decorator</i> - tweaking objects at runtime by adding functionality from predefined decorator objects.<br><br><i>Observer</i> - loose coupling by creating <i>observable</i> objects that notify all their <i>observers</i> when an interesting event occurs (<i>on-push</i> notification strategy).<br><br><i>Strategy</i> - keeping the same interface while selecting the best strategy to handle the specific task (context).<br><br><i>Adapter</i> - structural design pattern that allows objects with incompatible interfaces to collaborate.<br><br><i>Facade</i> - provides a more convenient API by wrapping common (or poorly designed) methods into a new one.<br><br><i>Proxy</i> - wrapping an object to control the access to it with the goal of avoiding expensive operations by either grouping them together or performing them only when really necessary.
Singleton,singleton single tone ton,<pre>const Singleton = (function () {<br>    let instance;<br><br>    return {<br>        getInstance: function () {<br>            if (!instance) {<br>                instance = new Object();<br>            }<br>            return instance;<br>        }<br>    };<br>})();<br>-------------------------------<br>class Singleton {<br>    constructor() {<br>        if (!Singleton.instance) {<br>            Singleton.instance = this;<br>        }<br>        return Singleton.instance;<br>    }<br>}<br>const instance = new Singleton();<br>Object.freeze(instance); // thread-safety</pre>
Functional programming,functional programming pure function,1. <i>Pure function</i> - function with no side effects; with the given input gives the same output.<br>2. <i>High order function</i> - a function that takes a function as an argument or returns a function.<br>3. <i>Functions as first-class objects</i> - functions can be assigned as variable or assigned to object property values.<br>4. <i>Carrying</i> - technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions each with a single argument.<br>5. <i>Immutable variables</i> - immutable objects are objects whose state cannot be changed after declaration.
Performance of app,performance,Performance can be tracked via different devtools tabs:<br>- <i>Performance</i> tab - allows to record a user interaction and to see a time spent on network requests; scripting; rendering; animation<br>- <i>Performance monitor</i> tab - tracks heap size; DOM nodes count; event listeners count; style recalculations<br>- <i>Memory</i> tab - makes memory record which shows which objects are being stored in memory and how much space they consume; you can also manually trigger GC and see the difference<br>- <i>https://pagespeed.web.dev/ - great Google tool for checking your website performance - great audit for many use-cases and devices</i><br><br>Performance optimization:<br>- stick to <i>async</i> style<br>- consider loading JS-scripts asyncronously (<i>async/defer</i>)<br>- use <i>sprites</i> for small images (one big image containing many small ones)<br>- <i>localStorage</i> is sync - might harm performance<br>- move from <i>Promises</i> to <i>Observables</i><br>- use caches (on backend and frontend)<br>- always think about algorythms' complexity<br>- consider <i>arr.slice()</i> instead of <i>[...arr]</i> on huge arrays<br>- consider <i>Maps</i> and <i>Sets</i> instead of objects and arrays<br>- consider <i>const enum</i> instead of <i>enum</i><br>- remember that native <i>.sort()</i> in JS has <i>O(n^2)</i> complexity<br><br>Specific for Angular:<br>- consider new Angular versions which supports <i>Ivy</i> and <i>Incremental Dom</i><br>- consider <i>lazy loading</i> eespecially when app have many pages/routes<br>- use memoization (ex: <i>NgRx</i> selectors)<br>- in template consider pipes instead of method calls<br>- prefer streams (<i>RxJS</i> style) rather then values<br>- consider <i>trackBy</i> in <i>*ngFor</i><br>- avoid repeted subscriptions in template<br>- consider <i>shareReplay</i> operator<br>- consider <i>debounceTime(0)</i> inside <i>combineLatest</i><br>
