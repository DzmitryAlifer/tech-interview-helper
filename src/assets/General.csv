topic,words,answer
OOP,oop oriented programming principle principles encapsulation abstraction inheritance polymorhysm association composition aggregation,<i>Encapsulation</i> (hidden implementation) - each object maintains a private state inside its class; other objects can not access this state directly - they can only invoke a list of public functions.<br><br><i>Abstraction</i> (encapsulation extension) - class should only represent information that is relevant to the problem's context; also it's about the extraction of some context which is shared between multiple classes and moving it to the parent class (such parent class is called an <i>abstract</i>) class.<br><br><i>Inheritance</i> - ability to create child classes based on parent classes.<br><br><i>Polymorphism</i> - means 'many forms' and it's the ability of one method to return different values according to certain conditions Example: same function with different signatures.<br><br><i>Association</i> - relation between two separate classes which establishes through their objects. It can be <i>one-to-one; one-to-many; many-to-one; many-to-many</i>. In OOP object communicates to another object to use functionality provided by that object.<br><br><i>Aggregation</i> (form of <i>Association</i>)- establishes one-way relation (<i>has-A</i> form); both the entries can survive individually e.g. ending one entity will not affect the other entity.<br><br><i>Composition</i> (form of <i>Aggregation</i>) - two entities are highly dependent on each other (<i>part-of</i> relationship).
SOLID,solid principle principles,<i>Single Responsibility</i> - class/component should have only one responsibility.<br><br><i>Open/Closed</i> - classes should be open for extension but closed for modification. E.g. we should avoid modifying existing code and causing potential new bugs.<br><br><i>Liskov Substitution</i> - extends open/closed principle; if class A is subtype of class B we should be able to replace A with B without disrupting the behavior of our program.<br><br><i>Interface Segregation</i> - larger interfaces should be split into smaller ones so we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.<br><br><i>Dependency Inversion</i> refers to decoupling of software modules e.g. instead of high-level modules depending on low-level modules both will depend on abstractions. Great example here is <i>Dependency Injection</i> pattern which allows to use dependencies without the knowledge about their instantiations.
Design patterns,design pattern patterns,<i>Singleton</i> - only one instance of class is possible.<br><i>Factory</i> - method that creates objects of type.<br><i>Iterator</i> - providing an API to loop over and navigate around a complex custom data structure.<br><i>Decorator</i> - tweaking objects at runtime by adding functionality from predefined decorator objects.<br><i>Observer</i> - loose coupling by creating <i>observable</i> objects that notify all their <i>observers</i> when an interesting event occurs (<i>on-push</i> notification strategy).<br><i>Strategy</i> - keeping the same interface while selecting the best strategy to handle the specific task (context).<br><i>Facade</i> - Providing a more convenient API by wrapping common (or poorly designed) methods into a new one.<br><i>Proxy</i> - wrapping an object to control the access to it with the goal of avoiding expensive operations by either grouping them together or performing them only when really necessary.
Singleton,singleton single tone ton,<pre>const Singleton = (function () {<br>    let instance;<br><br>    return {<br>        getInstance: function () {<br>            if (!instance) {<br>                instance = new Object();<br>            }<br>            return instance;<br>        }<br>    };<br>})();<br>-------------------------------<br>class Singleton {<br>    constructor() {<br>        if (!Singleton.instance) {<br>            Singleton.instance = this;<br>        }<br>        return Singleton.instance;<br>    }<br>}<br>const instance = new Singleton();<br>Object.freeze(instance); // thread-safety</pre>
Functional programming,functional programming pure function,1. <i>Pure function</i> - function with no side effects; with the given input gives the same output.<br>2. <i>High order function</i> - a function that takes a function as an argument or returns a function.<br>3. <i>Functions as first-class objects</i> - functions can be assigned as variable or assigned to object property values.<br>4. <i>Carrying</i> - technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions each with a single argument.<br>5. <i>Immutable variables</i> - immutable objects are objects whose state cannot be changed after declaration.
Sending request in browser,sending send request browser rendering render,1. Browser goes to the Domain Name System (DNS) server and finds the real IP address of the server that the website lives on.<br>2. Browser sends an HTTP request to server asking it to send a copy of the website to the client.<br>3. If the server approves the client's request the server sends the client a "200 OK" message and then starts sending the website's files to the browser as a series of small chunks called data packets.<br>4. Critical rendering path - browser assembles the small chunks into a complete web page and displays it to the user.
Critical rendering path,critical rendering render path sending send request browser,<i>CRP</i> - sequence of steps the browser goes through to convert the HTML CSS and JavaScript into pixels on the screen.<br><br>HTML is being parsed to create DOM. HTML may request JavaScript which may alter the DOM. HTML includes or makes requests for styles; the CSS object model is being built. The browser engine combines DOM and CSSOM to create Render Tree. Layout determines the size and location of everything on the page. Once layout is determined pixels are painted on the screen.
defer vs async,defer async,<i>Defer</i> - means execute code after it's downloaded and browser finished DOM construction and rendering process. Used for scripts that need the whole DOM.<br><br><i>Async</i> - means execute code when it is downloaded and do not block DOM construction during downloading process. Used for independent scripts like counters or ads.
Cross-Origin Resource Sharing,cross-origin resource sharing options,<i>CORS</i> - HTTP-header based mechanism that allows a server to indicate any origins (domain or port) other than its own from which a browser should permit loading resources.<br><br><i>CORS</i> relies on browser's 'preflight' OPTIONS http-request to the server hosting the cross-origin resource to check that the server will permit the actual request. In that 'preflight' the browser sends headers that indicate the HTTP method and headers that will be used in the actual request.<br><br>CORS can be adjusted by headers <i>Access-Control-Allow-Origin</i> and <i>Access-Control-Request-Method</i>.
Web vilnarabilities,web vulnarability,<i>XSS (cross-site scripting)</i> - allow to manipulate websites to return malicious scripts to visitors. Might happen when browser or application authors fail to implement the same origin policy.<br>To prevent:<br>1. Set flags on the set-cookie HTTP header: HttpOnly - does not allow JS access on the cookie<br>2. Send cookies only over HTTPS<br><br><i>CSRF (cross-site request forgery)</i> - allow to manipulate browsers to take unintended actions on other sites. Might happen when target sites authenticate requests solely using cookies and attackers are able to send requests carrying users' cookies.<br><br><i>SQL injection</i> - malicious SQL postfix in input fields (ex: <i>' or 1=1; --</i> at the end of password).
Performance of app,performance,Performance can be tracked via different devtools tabs:<br>- <i>Performance</i> tab - allows to record a user interaction and to see a time spent on network requests; scripting; rendering; animation<br>- <i>Performance monitor</i> tab - tracks heap size; DOM nodes count; event listeners count; style recalculations<br>- <i>Memory</i> tab - makes memory record which shows which objects are being stored in memory and how much space they consume; you can also manually trigger GC and see the difference<br><br>Performance optimization:<br>- stick to <i>async</i> style<br>- consider loading JS-scripts asyncronously (<i>async/defer</i>)<br>- use <i>sprites</i> for small images (one big image containing many small ones)<br>- <i>localStorage</i> is sync - might harm performance<br>- move from <i>Promises</i> to <i>Observables</i><br>- use caches (on backend and frontend)<br>- always think about algorythms' complexity<br>- consider <i>arr.slice()</i> instead of <i>[...arr]</i> on huge arrays<br>- consider <i>Maps</i> and <i>Sets</i> instead of objects and arrays<br>- consider <i>const enum</i> instead of <i>enum</i><br>- remember that native <i>.sort()</i> in JS has <i>O(n^2)</i> complexity<br><br>Specific for Angular:<br>- use memoization (ex: <i>NgRx</i> selectors)<br>- in template consider pipes instead of method calls<br>- prefer streams (<i>RxJS</i> style) rather then values<br>- consider <i>trackBy</i> in <i>*ngFor</i><br>- avoid repeted subscriptions in template<br>- consider <i>shareReplay</i> operator<br>- consider <i>debounceTime(0)</i> inside <i>combineLatest</i><br>
