topic,words,answer
RxJS,rxjs library,<i>RxJS</i> - library for composing async and callback-based code in a functional reactive style using <i>Observables</i>.
Observable,observable observables absorbable,<i>Observable</i> a source of a stream of values. It implements the behavioral design patterns <i>Observer</i> (push notifications strategy) and Iterator. <br><br><i>Observer</i> design pattern: an object (<i>subject</i>) maintains a list of its dependents (<i>observers</i>) and notifies them automatically of any state changes.
Pull vs push notifications,pull push notification notifications,<i>Pull</i> notification - client asks server to check if there are any updates.<br><br><i>Push</i> notification - server notifies client about the updates.
Observable vs Promise,observable observables absorbable promise,Often Observable is preferred over Promise because it provides the features of Promise and more.<br><br>Benefits of <i>Observable</i>:<br><br>1. <i>Promise</i> handles a single event when an async operation fulfills. <i>Observable</i> is like a stream so its value might change over time.<br>2. <i>Observable</i> is lazy. While <i>Promise</i> starts immediately (eager) <i>Observable</i> only starts if you subscribe to it.<br>3. Unlike <i>Promise</i> the <i>Observable</i> can be cancelled.<br>4. <i>Observables</i> use a lot of very powerful operators.
Observable creation,observable observables absorbable create creation graichen,1. From value/object: <i>of({})</i><br>2. From promise: <i>from(promise)</i><br>3. From event: <i>fromEvent(button; 'mouseover')</i><br>4. From counter: <i>interval(1000)</i><br>5. Via constructor: <i>new Observable(observer => ...)</i><br>6. From other observables using operators
Observer,observer,<i>Observer</i> design pattern: an object (<i>subject</i>) maintains a list of its dependents (<i>observers</i>) and notifies them automatically of any state changes.<br><br><i>Observer</i> - consumer of push-based values delivered by <i>Observable</i>. <i>Observers</i> are simply a set of callbacks one for each type of notification delivered by the Observable: <i>next error complete</i>.
Subscription,subscription,<i>Subscription</i> is a representation of disposable resource. <i>Subscription</i> has <i>unsubscribe</i> and <i>add</i> methods. 
Observable vs Subject,observable observables absorbable subject unicast multicast,<i>Observable</i> is unicast by default. <i>Observer</i> and its subscribers have a one-to-one relationship. Each subscribed <i>observer</i> owns an independent execution of <i>Observable</i>.<br><br><i>Subject</i> is a special type of <i>Observable</i> that allows values to be multicasted to many observers. <i>Subject</i> and its subscribers have a one-to-many relationship.<br><br><i>Observable</i> is <i>cold</i> by default whilst <i>Subject</i> is <i>hot</i>.
Subject vs BehaviorSubject vs ReplaySubject,subject behavior replay,<i>BehaviorSubject</i> - a subject with the provided initial value. <br><br><i>ReplaySubject</i> a subject that replays a fixed amount of values to new subscribers. <i>ReplaySubject(n)</i> sends last <i>n</i> values to the subscriber.
Hot vs cold observables,observable observables absorbable hot cold call called,In RxJS observables are <i>cold</i> or <i>unicast</i> by default. <i>Cold</i> observable produces data inside observable. They start pushing events only when there is a subscription to it. <br><br><i>Hot</i> observable produces data outside observable. They push events even if there are no subscribers. Hot observable examples: subjects; mouseover event; websocket messages.<br><br>Operators to make an observable <i>hot</i> or multicast sharing value among multiple subscribers: <i>publish multicast share shareReplay</i>.
combineLatest,combine combined latest,Creates a stream that will have a new value every time one of the source streams changes.