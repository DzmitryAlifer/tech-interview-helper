topic,words,answer
Types,types type stripes babes,Primitive: <i>string number boolean undefined null symbol bigint</i>.<br>Non-primitive: Object (incl. Array Function Date Error Map Set).<br><br>Ways to define type:<br>1. <i>typeof</i> - not the best way since <i>typeof null</i> and <i>typeof new String('s')</i> and <i>typeof []</i> are all <i>'object'</i><br>2. <i>instanceof</i> - much better since it looks for the <i>constructor</i> property in the prototype chain; <i>[] instanceof Array</i> is <i>true</i><br>3. <i>Object.prototype.toString.call(...)</i>
Object creation,create object budget creation graichen,1. Function based:  function User(name) { this.name = name; } const user = new User('John'); <br>2. Object literal: const user = { name: 'John' }; <br>3. new Object: const user = new Object(); user.name = 'John'; <br>4. Object.create: const user = Object.create(person); // person is user's prototype (user inherits properties of person)
Strict mode,use strict mode streak drink mould,In ES5 a new feature called <i>Strict Mode</i> allows to write code in a strict operational environment. It's much less error-prone since all forms of errors(including silent errors) will be thrown.
Pure function,pure your poor function beautiful action beautification,1. Given the same input always returns the same output. <br>2. Produces no side-effects.
var vs let,var let bar farm blacked elect,<i>var</i> has function scope and is hoisted (initialized with undefined before the code is run). <br><br><i>let</i> has block scope and isn't hoisted (technically it's hosted without initialization). Let was introduced because function scope is confusing and was one of the main sources of bugs in JS.
this,this these keyword keywords keyboard keyboards,<i>this</i> refers to the current execution context - the object on which the function was called. In case of self-executed function <i>this</i> refers to <i>Window/Global</i> object. The same is for function declaration which is not a method.
bind call apply,bind call apply bynes buying,They allow to redefine <i>this</i>. <br><br><i>call()</i> - invokes a function with a given this value and args provided one by one. <br><br><i>apply()</i> -  invokes a function with a given this value and args passed as an array. <br><br><i>bind()</i> - returns a new function that will have <i>this</i> set to the 1st arg passed to bind().
Hoisting,hoisting hosting hoist wasting,<i>Hoisting</i> is the default JS behavior when all the var and function declarations are moved on top of their scope (global or local) without their value initialization.
Scope,scope school scola scopes,<i>Scope</i> determines the accessibility of vars and funcs at various parts of code. The scope is the current context of execution in which values and expressions are visible or can be referenced. If variable cannot be found in local scope JS engine tries to check for the variable in the outer scope. If no success it tries to find it in the global scope. <br><br><i>Global scope</i> - vars or funcs declared in the global namespace can be accessed from anywhere. <br><br><i>Module scope</i> - exported members of one file can be imported inside another. <br><br><i>Function/local scope</i> - can be accessed from within the function and not outside of it. <br><br><i>Block scope</i> relates only to let and const (var declarations don't have block scope); can be accessed only inside {} block.
Scope chaining,scope school scola scope chain chaining,JS tries to find variable in local scope and if not then it tries to find var inside upper scope etc until it is found or <i>ReferenceError</i>.
Closure,closure florida gloria,<i>Closure</i> - combination of a function with references to its surrounding state (the lexical environment). In other words <i>closure</i> gives you access to an outer function's scope from an inner function. <br><br>In JS <i>closures</i> are created every time a function is created at function creation time.
Arrow vs traditional function,arrow animal function functions fraction fractions,<i>Arrow</i> functions introduced by ES6. Differences with regular function: <br><br>1. <i>this</i>: inside the <i>regular</i> function <i>this</i> keyword refers to the object on which the func is being called whilst inside <i>arrow</i> func <i>this</i> inherits its value from parent scope. <br><br>2. <i>constructor</i> - <i>regular</i> func can be used as a constructor for object creation. <br><br>3. <i>arguments</i> - inside <i>regular</i> func <i>arguments</i> is an array-like object containing the list of arguments with which func has been invoked; <i>arrow</i> func has no its own <i>arguments</i> keyword. <br><br>4. <i>implicit return</i> - <i>undefined</i> is being returned implicitely from <i>regular</i> func if there is no <i>return</i> statement.<br><br>5. <i>Regular</i> funcs are hoisted and can be used before declaration (unlike <i>arrow</i> ones).
Prototype,prototype,<i>Prototype</i> - creational design pattern that lets you copy existing objects without making your code dependent on their classes. In JS it allows to produce objects with methods and properties predefined in the <i>prototype</i> class. <br><br><i>Prototype</i> is useful and memory efficient way of declaring methods for objects of the same type. Alternatively if we'll be declaring methods directly in JS objects a new copy of the method will be created for each instance of an object. <br><br><i>Prototype</i> chaining is used to build new types of objects based on existing ones. It is similar to inheritance in a class based language. <br><br>Object's <i>prototype</i> is available through <i>Object.getPrototypeOf(object)</i> or <i>__proto__</i> property whereas <i>prototype</i> on constructors function is available through <i>Object.prototype</i>. <br><br><i>Object.prototype</i> functions: <i>toString toLocaleString valueOf hasOwnProperty isPrototypeOf propertyIsEnumerable</i>.
Event bubbling,event events bubble bubbling,<i>Event bubbling</i> - method of event propagation in the HTML DOM API when an event is in an element inside another element and both elements have registered a handle to that event. It is a process that starts with the element that triggered the event and then bubbles up to the containing elements in the hierarchy. In <i>event bubbling</i> the event is first captured and handled by the innermost element and then propagated to outer elements.<br><br><i>addEventListener(type; listener; useCapture)</i><br><i>type</i> - type of event<br><i>listener</i> - handler func which is called when event happened<br><i>useCapture</i> - indicates whether event is in bubbling phase 
Event loop,async event events loop even eventful eventually antelope micro macro microtask macrotask,<i>Event loop</i> - mechanism that allows asynchronously execute non-blocking operations despite the fact JS is single-threaded (which improves the performance of an application). <br><br>When an async task is started the <i>EL</i> starts running. Once the task is completed <i>EL</i> again checks for any other tasks that need to be performed. This process continues until all tasks have been completed. <br><br>There are 3 "stacks" in JS:<br>1. <i>synchronous</i> calls stack (one function calls another etc)<br>2. <i>microtask</i> queue (or job queue or microtask stack) for all async operations with higher priority (<i>process.nextTick Promise Object.observe MutationObserver</i>)<br>3. <i>macrotask</i> queue (or event queue) for all async operations with lower priority (<i>setTimeout setInterval requestAnimationFrame</i> I/O UI rendering)<br><br>Task execution order:<br>1. all microtasks first<br>2. one macrotask<br>3. all (newly added) microtasks again<br>4. next macrotask<br>5. repeat
setTimeout,set timeout timer,The time value represents the (minimum) delay after which the message will be pushed into the queue. If there is no other task in the queue and the stack is empty the task is processed right after the delay. However if there are tasks the <i>setTimeout</i> task will have to wait for other tasks to be processed. For this reason 2nd argument indicates a minimum time â€” not a guaranteed time.
Web socket,socket websocket website web,<i>WebSocket</i> - event-driven protocol which means you can actually use it for truly realtime communication. <br><br>Unlike <i>HTTP</i> where you have to constantly request updates with <i>WebSocket</i> updates are sent immediately when they are available. <br><br><i>WebSocket</i> keeps a single persistent connection open while eliminating latency problems that arise with <i>HTTP</i> request/response-based methods. <br><br><i>WebSocket</i> generally does not use <i>XMLHttpRequest</i> so headers are not sent every-time we need to get more information from the server. It reduces the expensive data loads being sent to the server.
Promise,promise premise,<i>Promise</i> - wrapper/proxy for <i>async</i> operation result which allows via its handlers to resolve it into a <i>sync</i> value. Instead of immediately returning the final value the <i>async</i> method returns <i>promise</i> to supply the value at some point in the future. <br><br><i>Promise</i> is created using the Promise constructor which takes 2 callbacks as parameters: <i>resolve</i> and <i>reject</i>. <br><br>Promise states:<br>1. <i>pending</i> - initial state (promise has neither been <i>fulfilled</i> nor <i>rejected</i>)<br>2. <i>fulfilled</i> - async operation has accomplished<br>3. <i>rejected</i> - async operation has failed<br>4. <i>settled</i> - <i>rejected</i> or <i>fulfilled</i>. <br><br>Instance methods: <i>then catch finally</i> <br><br>Static methods: <i>resolve reject all allSettled any</i>
Client-side storages,storage storages,1. Cookies<br>2. Session storage<br>3. Local storage<br>4. Cache storage<br>5. Indexed DB.
Service workers,service worker workers,<i>SW</i> - script that runs in web browser and manages caching for app. Works with HTTPS not HTTP. <i>SW</i> allow the app to use cached resources first and provide default experience offline before getting more data from the network later. <i>SW</i> actively use promises. <i>SW</i> has to be installed and activated and then it can react on fetch push and sync events. <br><br><i>SW</i> can't access the DOM directly; it can communicate with the pages it controls by responding to messages sent via the <i>postMessage</i> interface and those pages can manipulate the DOM.
GC algorithms,garbage collector collection,<i>GC</i> - memory cleanup performed automatically (we cannot force or prevent it). <br><br>GC algorythms:<br>1. <i>Reference count</i> - refs to object are being counted and if the their number is 0 then it's marked as collectible. Mem leak with circular refs thus modern browsers don't use it. <br>2. <i>Mark-and-sweep</i> - improvement over previous one. Helps to define circular refs. Periodically tries to reach all refs from so-called global root objects. Marks the object as collectible if it cannot be reached from the root one. <br>3. <i>Generational collection</i> (<i>Mark-and-Sweep</i> optimization) - objects are split into two sets: <i>new ones</i> and <i>old ones</i>. Many objects have a short life span: they appear do their job and die fast so it makes sense to track new objects and clear the memory from them if that's the case. Those that survive for long enough become <i>old</i> and are examined less often. <br>4. <i>Incremental collection</i> (<i>Mark-and-Sweep</i> optimization) - if there are many objects and we try to walk and mark the whole object set at once it may take some time and introduce visible delays in the execution. So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small GCs instead of a total one. That requires some extra bookkeeping between them to track changes but we get many tiny delays instead of a big one. <br>5. <i>Idle-time collection</i> (<i>Mark-and-Sweep</i> optimization) - GC tries to run only while the CPU is idle to reduce the possible effect on the execution.
Weak collections,weak week,<i>WeakSet</i> - non-iterable collection that contains only objects and no other type. Set contains strong references to the objects whilst WeakSet contains weak references (GCed if no other references to a key object). <br><br><i>WeakMap</i> - non-iterable key/value collection whose keys must be objects without strong references (object's presence as a key in a <i>WeakMap</i> does not prevent the object from being GCed). <i>WeakMap</i> can be useful for mapping keys to values when it's valuable ONLY if the key has not been GCed. Since <i>WeakMap</i> doesn't allow observing the liveness of its keys it is not iterable.
Generics,generic generics,<i>Generics</i> are the way to describe the similar model or functionality for different types.<br><br>Generic function: <i>function getObj< Type >(arg: Type): Type {return arg;}</i><br>Generic interface: <i>interface GenericIdentity1 {< Type >(arg: Type): Type;}</i> or <i>interface GenericIdentity2< Type > {(arg: Type): Type;}</i><br>Generic class: <i>class GenericIdentity3< Type > {value: Type;}</i>
Interface,interface interfaces,<i>Interface</i> - public contract that other types implementing it should follow. All properties of the interface should be public. We can use an interface as the basis for our types hierarchy.
Class,class classes,<i>Class</i> - unit of OOP designed to encapsulate parts of logic with possibility to share it through inheritance. We can use classes as a matter for defining different parts of our app.
