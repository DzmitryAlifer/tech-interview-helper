topic,words,answer
JavaScript,javascript language,<i>JavaScript</i> was initially created to make web pages alive. The programs in this language are called scripts. They can be written right in HTML and run automatically as the page loads. Scripts are provided and executed as plain text. They don't need compilation to run. In case of ES6 code it should be transpiled to ES5 (by means of <i>Babel</i>) and then executed.<br><br>JS can be executed not only in the browser but also on the server or actually on any device that has a special program called the JS engine.<br><br>JS is a <i>weakly-typed</i> language because it has <i>no compilation</i> stage at which strongly-typed languages validate types.
Types,types type stripes babes,Primitive types: <i>string number boolean undefined null symbol bigint</i>.<br>Reference types: Object (incl. Array Function Date Error Map Set).<br><br><i>Primitives</i> are passed by value (value copy); <i>reference types</i> - by reference as a value.<br><br>Ways to define type:<br>1. <i>typeof</i> - not the best way since <i>typeof null</i> and <i>typeof new String('s')</i> and <i>typeof []</i> are all <i>'object'</i><br>2. <i>instanceof</i> - much better since it looks for the <i>constructor</i> property in the prototype chain; <i>[] instanceof Array</i> is <i>true</i><br>3. <i>Object.prototype.toString.call('js') // '[object String]'</i>
Object creation,create object budget creation graichen,1. Function based:  function User(name) { this.name = name; } const user = new User('John'); <br>2. Object literal: const user = { name: 'John' }; <br>3. new Object: const user = new Object(); user.name = 'John'; <br>4. Object.create: const user = Object.create(person); // person is user's prototype (user inherits properties of person)
Shallow vs Deep copy,shallow deep copy,<i>Shallow copy</i> - copy whose properties share the same references (same values that refer to the same memory addresses).<br><i>{...obj}; [...arr]; Object.create(); Object.assign(); arr.slice(); Array.from(arr)</i><br><br><i>Deep copy</i> - copy whose properties are not the same references.<br>If object is serializable (e.g. not <i>function</i> or <i>HTMLElement</i>) it can deeply copied: <i>JSON.parse(JSON.stringify(obj))</i>.<br><br>If object is not serializable (not literal):<br><pre>function deepCopy(obj) {<br>  if (!obj) return obj;<br><br>  const copyObj = {};<br>  for (const key in obj) {<br>    if (typeof obj[key] !== "object" || Array.isArray(obj[key]))<br>      copyObj[key] = obj[key];<br>    else copyObj[key] = deepCopy(obj[key]);<br>  }<br>  return copyObj;<br>}</pre>
Immutability,immutability immutable mutable freeze seal,<i>Object.freeze()</i> - fully immutable<br><i>Object.seal()</i> - can change values; cannot add or delete or redefine properties<br><i>Object.preventExtensions()</i> - can change and delete props; cannot add.
Strict mode,use strict mode streak drink mould,In ES5 a new feature called <i>Strict Mode</i> allows to write code in a strict operational environment. It's much less error-prone since all forms of errors(including silent errors) will be thrown.
Pure function,pure your poor function beautiful action beautification,1. Given the same input always returns the same output. <br>2. Produces no side-effects.
Var vs let,var let bar farm blacked elect,<i>var</i> has function scope and is initialized with <i>undefined</i> before the code is run due to <i>hoisting</i>. <br><br><i>let</i> has block scope and isn't initialized while getting <i>hoisted</i>. <i>let</i> and <i>const</i> was introduced because function scope is confusing and was one of the main sources of bugs in JS.
This,this these keyword keywords keyboard keyboards,<i>this</i> refers to the current execution context - the object on which the function was called.<br><br>Use-cases:<br>- <i>method</i> - <i>this</i> refers to object<br>- <i>regular function</i> - in <i>non-strict</i> mode refers to <i>Window/Global</i> object; in <i>strict</i> mode is <i>undefined</i><br>- <i>self-executed function</i> - <i>this</i> refers to <i>Window/Global</i> object<br>- <i>arrow function</i> - <i>this</i> refers to parent scope<br>- in <i>class</i> - refers to class object
Bind call apply,bind call apply bynes buying,They allow to redefine <i>this</i>.<br><i>call()</i> - invokes a function with a given this value and args provided one by one.<br><i>apply()</i> -  invokes a function with a given this value and args passed as an array.<br><i>bind()</i> - returns a new function that will have <i>this</i> set to the 1st arg passed to bind().
Hoisting,hoisting hosting hoist wasting dead dad zone,<i>Hoisting</i> is the default JS behavior when all the declarations (<i>var const let function class</i>) are moved to the top of their scope (global or local). At the same time <i>var</i> is initialized with <i>undefined</i>. Others (<i>let const class</i>) - not initialized. Calling them before the initialization causes <i>ReferenceError</i>.<br><br><i>Temporal Dead Zone</i> - period of time during which <i>let</i> and <i>const</i> declarations cannot be accessed.
Scope,scope school scola scopes,<i>Scope</i> determines the accessibility of vars and funcs at various parts of code. The scope is the current context of execution in which values and expressions are visible or can be referenced. If variable cannot be found in local scope JS engine tries to check for the variable in the outer scope. If no success it tries to find it in the global scope. <br><br><i>Global scope</i> - vars or funcs declared in the global namespace can be accessed from anywhere.<br><i>Module scope</i> - exported members of one file can be imported inside another.<br><i>Function/local scope</i> - can be accessed from within the function and not outside of it.<br><i>Block scope</i> relates only to let and const (var declarations don't have block scope); can be accessed only inside {} block.
Scope chaining,scope school scola scope chain chaining,JS tries to find variable in local scope and if not then it tries to find var inside upper scope etc until it is found or <i>ReferenceError</i>.
Closure,closure florida gloria,<i>Closure</i> - combination of a function with references to its surrounding state (the lexical environment). In other words <i>closure</i> gives you access to an outer function's scope from an inner function. <br><br>In JS <i>closures</i> are created every time a function is created at function creation time.
Currying,curring carrying carry,<i>Currying</i> - partial invocation of a function providing arguments in advance. It creates closure and returns new function. It's possible due to <i>scope chaining</i>.
Arrow vs traditional function,arrow animal function functions fraction fractions,<i>Arrow</i> functions introduced by ES6. Differences with regular function:<br>1. <i>this</i>: inside the <i>regular</i> function <i>this</i> keyword refers to the object on which the func is being called whilst inside <i>arrow</i> func <i>this</i> inherits its value from parent scope.<br>2. <i>constructor</i> - <i>regular</i> func can be used as a constructor for object creation.<br>3. <i>arguments</i> - inside <i>regular</i> func <i>arguments</i> is an array-like object containing the list of arguments with which func has been invoked; <i>arrow</i> func has no its own <i>arguments</i> keyword.<br>4. <i>implicit return</i> - <i>undefined</i> is being returned implicitely from <i>regular</i> func if there is no <i>return</i> statement.<br>5. <i>Regular</i> funcs are hoisted and can be used before declaration (unlike <i>arrow</i> ones).
Map vs Object,map object, <i>Map</i>:<br>- keys can be anything but should be of the same type (same for values)<br>- iteration order guaranteed (elements in a map retain insertion order)<br>- has a size property<br><br><i>Object</i>:<br>- keys must be string literals; values can be anything<br>- iteration order is not guaranteed<br>- has prototype<br>- has no size property<br><br><i>Objects</i> should be used for records where you have a fixed and finite number of properties known at from the beginning. Property access time complexity is <i>O(1)</i><br><br><i>Maps</i> are for variable number of entries with frequent updates. Property access time complexity is <i>O(1)</i> (<i>O(n)</i> in worst case scenario). But still it is more performant than <i>Object</i>.
Prototype,prototype prototypal inheritance,<i>Prototype</i> - creational design pattern that lets you copy existing objects without making your code dependent on their classes. In JS it allows to produce objects with methods and properties predefined in the <i>prototype</i> class. <br><br><i>Prototype</i> is useful and memory efficient way of declaring methods for objects of the same type. Alternatively if we'll be declaring methods directly in JS objects a new copy of the method will be created for each instance of an object. <br><br><i>Prototypal inheritance (chaining)</i> is used to build new types of objects based on existing ones. It is similar to inheritance in a class based language. <br><br>Object's <i>prototype</i> is available through <i>Object.getPrototypeOf(object)</i> or <i>__proto__</i> property whereas <i>prototype</i> on constructors function is available through <i>Object.prototype</i>. <br><br><i>Object.prototype</i> functions: <i>toString; toLocaleString; valueOf; hasOwnProperty; isPrototypeOf; propertyIsEnumerable</i>.<br><br><i>hasOwnProperty</i> cannot look into prototype chain proprties.<br><br><i>prototype</i> - property of a Function object; it is prototype of objects constructed by that function.<br><br><i>__proto__</i> - internal property of an object pointing to its <i>prototype</i>; going upwards the top level <i>__proto__</i> refers to <i>null</i>.
Event propagation (bubbling vs capturing),event events bubble bubbling propagation,Event <i>bubbling</i> and <i>capturing</i> are two ways of event propagation in the HTML DOM API when an event occurs in an element inside another element and both elements have registered a handle for that event. The event propagation mode determines in which order the elements receive the event.<br><br><i>Bubbling</i> - event is first captured and handled by the innermost element and then propagated to outer elements.<br><br><i>Capturing</i> - event is first captured by the outermost element and propagated to the inner elements.<br><br><i>addEventListener(type; listener; useCapture)</i><br><i>type</i> - type of event<br><i>listener</i> - handler func which is called when event happened<br><i>useCapture</i> - indicates whether event is in bubbling phase 
StopPropagation vs preventDefault,event stop propagation prevent default,<i>stopPropagation()</i> method of the <i>Event</i> interface prevents further propagation of the current event in <i>bubbling</i> and <i>capturing</i> phases. However it doesn't prevent any default behaviors from occurring; for instance click on the link is still processed. To stop this default behavior <i>preventDefault()</i> method should be used. It also does not prevent immediate propagation to other event-handlers. To stop those there is <i>stopImmediatePropagation()</i>.
Event loop,async event events loop poop even eventful eventing eventually eventable ivanka antelope micro macro microtask macrotask concurrency,<i>Event loop</i> - mechanism that allows asynchronously execute non-blocking operations despite the fact JS is single-threaded (which improves the performance of an application). <br><br>When an async task is started the <i>EL</i> starts running. Once the task is completed <i>EL</i> again checks for any other tasks that need to be performed. This process continues until all tasks have been completed. <br><br>There are 3 "stacks" in JS:<br>1. <i>synchronous</i> calls stack (one function calls another etc)<br>2. <i>microtask</i> queue (or job queue or microtask stack) for all async operations with higher priority (<i>process.nextTick Promise Object.observe MutationObserver</i>)<br>3. <i>macrotask</i> queue (or event queue) for all async operations with lower priority (<i>setTimeout setInterval requestAnimationFrame</i> I/O UI rendering)<br><br>Task execution order:<br>1. all microtasks first<br>2. one macrotask<br>3. all (newly added) microtasks again<br>4. next macrotask<br>5. repeat
Promise,promise premise,<i>Promise</i> - wrapper/proxy for <i>async</i> operation result which allows via its handlers to resolve it into a <i>sync</i> value. Instead of immediately returning the final value the <i>async</i> method returns <i>promise</i> to supply the value at some point in the future. <br><br><i>Promise</i> is created using the Promise constructor which takes 2 callbacks as parameters: <i>resolve</i> and <i>reject</i>.<br>Ex: <i>new Promise((resolve; reject) => {resolve(5)}).then(console.log)</i> <br><br>Promise states:<br>1. <i>pending</i> - initial state (promise has neither been <i>fulfilled</i> nor <i>rejected</i>)<br>2. <i>fulfilled</i> - async operation has accomplished<br>3. <i>rejected</i> - async operation has failed<br>4. <i>settled</i> - <i>rejected</i> or <i>fulfilled</i>. <br><br>Instance methods: <i>then catch finally</i> <br><br>Static methods: <i>resolve reject all allSettled any</i>
RequestAnimationFrame,request animation frame,<i>window.requestAnimationFrame(callback)</i> - tells the browser that you wish to perform an animation and requests that the browser calls a specified function to update an animation before the next repaint. The method takes a callback as an argument to be invoked before the repaint. Returns request ID - long int value that can be passed to <i>cancelAnimationFrame(id)</i><br><br><i>requestAnimationFrame</i> vs <i>setTimeout</i><br><i>requestAnimationFrame</i> produces higher quality animation completely eliminating flickering that can happen when using <i>setTimeout</i> or <i>setInterval</i>. This happens because after being put into macrotask queus <i>setTimeout</i> on each EL iteration (after running all the microtasks) checks if it's the right time passed to execute its callback. <i>setTimeout</i> is forced to take at least the amount of time defined by delay.
SetTimeout,set timeout timer,The time value represents the (minimum) delay after which the message will be pushed into the queue. If there is no other task in the queue and the stack is empty the task is processed right after the delay. However if there are tasks the <i>setTimeout</i> task will have to wait for other tasks to be processed. For this reason 2nd argument indicates a minimum time â€” not a guaranteed time.
Web socket,socket websocket website web,<i>WebSocket</i> - event-driven protocol which means you can actually use it for truly realtime communication.<br>Unlike <i>HTTP</i> where you have to constantly request updates with <i>WebSocket</i> updates are sent immediately when they are available. <i>WebSocket</i> keeps a single persistent connection open while eliminating latency problems that arise with <i>HTTP</i> request/response-based methods. <i>WebSocket</i> generally does not use <i>XMLHttpRequest</i> so headers are not sent every-time we need to get more information from the server. It reduces the expensive data loads being sent to the server.
Client-side storages,storage storages,1. Cookies<br>2. Session storage<br>3. Local storage<br>4. Cache storage<br>5. Indexed DB.
Workers: web vs service workers,concurrency multi-threading but parker parkers web when service worker workers water waters walker walkers watercourse porker porkers marker markers,<i>Workers</i> - scripts that run in a separate thread than the main browser thread. The allow system to run code without blocking. Workers cannot access DOM.<br><br><i>Web workers</i> - not dedicated to some specific kind of work. They just available for main thread's load separation at any moment. They have methods: <i>onmessage; postMessage; onchange; terminate</i>.<pre>// app.js<br>const ww = new Worker('worker.js');<br>ww.postMessage('Start');<br>ww.onmessage = function(e) {console.log(e.data);}<br>// worker.js<br>self.onmessage = function(e) {<br>  console.log(e.data);<br>  self.postMessage(workerResult);<br>}</pre><i>Service worker</i> - script that runs in web browser and manages caching for app. Works with HTTPS not HTTP. <i>SW</i> allow the app to use cached resources first and provide default experience offline before getting more data from the network later. <i>SW</i> actively use promises. <i>SW</i> has to be installed and activated and then it can react on fetch push and sync events. <br><br><i>SW</i> can't access the DOM directly; it can communicate with the pages it controls by responding to messages sent via the <i>postMessage</i> interface and those pages can manipulate the DOM.
Memory model,memory model management,<a href='https://deepu.tech/memory-management-in-v8/'>Memory model</a>
Garbage collection,garbage collector collection memory leak leaks,<i>GC</i> - memory cleanup performed automatically (we cannot force or prevent it). <br><br>GC algorythms:<br>1. <i>Reference count</i> - refs to object are being counted and if the their number is 0 then it's marked as collectible. Mem leak with circular refs thus modern browsers don't use it. <br>2. <i>Mark-and-sweep</i> - improvement over previous one. Helps to define circular refs. Periodically tries to reach all refs from so-called global root objects. Marks the object as collectible if it cannot be reached from the root one. <br>3. <i>Generational collection</i> (<i>Mark-and-Sweep</i> optimization) - objects are split into two sets: <i>new ones</i> and <i>old ones</i>. Many objects have a short life span: they appear do their job and die fast so it makes sense to track new objects and clear the memory from them if that's the case. Those that survive for long enough become <i>old</i> and are examined less often. <br>4. <i>Incremental collection</i> (<i>Mark-and-Sweep</i> optimization) - if there are many objects and we try to walk and mark the whole object set at once it may take some time and introduce visible delays in the execution. So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small GCs instead of a total one. That requires some extra bookkeeping between them to track changes but we get many tiny delays instead of a big one. <br>5. <i>Idle-time collection</i> (<i>Mark-and-Sweep</i> optimization) - GC tries to run only while the CPU is idle to reduce the possible effect on the execution.<br><br><i>Memory leaks</i> - Memory leaks = objects that can't be freed up by the GC. Common reasons are closures; timers; detached DOM elements. We can track them through devtools' <i>Memory</i> tab (we can record <i>Heap</i> usage there).
Weak collections,weak week,<i>WeakSet</i> - non-iterable collection that contains only objects and no other type. Set contains strong references to the objects whilst WeakSet contains weak references (GCed if no other references to a key object). <br><br><i>WeakMap</i> - non-iterable key/value collection whose keys must be objects without strong references (object's presence as a key in a <i>WeakMap</i> does not prevent the object from being GCed). <i>WeakMap</i> can be useful for mapping keys to values when it's valuable ONLY if the key has not been GCed. Since <i>WeakMap</i> doesn't allow observing the liveness of its keys it is not iterable.
Engines,engine engines,<i>V8 (Chrome)</i> - was originally built for Google Maps introduced in 2004. By that time there was the only JS engine <i>SpiderMonkey</i> which was a simple interpreter-executor and was simple unable to deal with that code.<br>- parses code<br>- generates abstract syntax tree<br>- generates bytecode from this syntax tree<br>- compiles bytecode into machine code<br>- uses inline caching<br><br><i>SpiderMonkey (Netscape then Firefox)</i> - first JS engine.<br><br><i>JS Core Webkit (Safari; PlayStation)</i>
Generator,generator,<i>Generator</i> - object is returned by a generator function (<i> function*</i>) and it conforms to both <i>iterable</i> and <i>iterator</i> protocols. Generator's <i>next()</i> method returns obj <pre>{value: 'a'; done: false}</pre>. <i>done</i> indicates if we passed through this value or not.
Babel,babel,JS transpiler used to convert <i>ES6+</i> to <i>ES5</i> to be run in any browser. Uses polyfills to provide missing support for various methods.
