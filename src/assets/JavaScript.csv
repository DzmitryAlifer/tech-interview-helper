topic,words,answer
Types,types type stripes,Object String Symbol Number BigInt Boolean null undefined
Object creation,create object creation graichen,1. Function based:  function User(name) { this.name = name; } const user = new User('John'); 2. Object literal: const user = { name: 'John' }; 3. new Object: const user = new Object(); user.name = 'John'; 4. Object.create: const user = Object.create(person); // person is user's prototype (user inherits properties of person)
Strict mode,use strict mode streak drink,In ES5 a new feature called Strict Mode allows to write code in a strict operational environment. It's much less error-prone since all forms of errors(including silent errors) will be thrown.
Pure function,pure your,1. Given the same input always returns the same output. 2. Produces no side-effects.
var vs let,var let bar farm,var has function scope and is hoisted (initialized with undefined before the code is run). let has block scope and isn't hoisted. Let was introduced because function scope is confusing and was one of the main sources of bugs in JS.
this,this these keyword keywords keyboard keyboards,'this' refers to the current execution context - the object on which the function was called. In case of self-executed function 'this' Window/Global object. The same is for function declaration which is not a method.
bind call apply,bind call apply bynes buying,They allow to redefine 'this'. call() - invokes a function with a given this value and args provided one by one. apply() -  invokes a function with a given this value and args passed as an array. bind() - returns a new function that will have this set to the 1st arg passed to bind().
Hoisting,hoisting hosting,Hoisting is the default JS behavior when all the var and function declarations are moved on top of their scope (global or local) without their value initialization.
Scope,scope school scola scopes,Scope determines the accessibility of vars and funcs at various parts of code. Global scope: vars or funcs declared in the global namespace can be accessed from anywhere. Module scope: exported members of one file can be imported inside another. Function/local scope: can be accessed from within the function and not outside of it. Block scope: relates only to let and const (var declarations don't have block scope); can be accessed only inside {} block. The scope is the current context of execution in which values and expressions are visible or can be referenced. If variable cannot be found in local scope JS engine tries to check for the variable in the outer scope. If no success it tries to find it in the global scope.
Scope chaining,chain chaining,JS tries to find variable in local scope and if not then it tries to find var inside upper scope etc until it is found or referenceError.
Closure,closure florida gloria,Closure is the combination of a function with references to its surrounding state (the lexical environment). In other words a closure gives you access to an outer function's scope from an inner function. In JavaScript closures are created every time a function is created at function creation time.
Arrow vs traditional function,arrow,Introduced by ES6. The biggest difference: inside the traditional function this keyword refers to the object on which the function is being called whilst inside arrow function 'this' inherits its value from parent scope.
Prototype,prototype,Prototype is a creational design pattern that lets you copy existing objects without making your code dependent on their classes. In JS it allows to produce objects with methods and properties predefined in the prototype class. Prototype is a useful and memory efficient way of declaring methods for objects of the same type. Alternatively if we'll be declaring methods directly in JS objects a new copy of the method will be created for each instance of an object. Prototype chaining is used to build new types of objects based on existing ones. It is similar to inheritance in a class based language. Object's prototype is available through Object.getPrototypeOf(object) or __proto__ property whereas prototype on constructors function is available through Object.prototype. Object.prototype functions: toString toLocaleString valueOf hasOwnProperty isPrototypeOf propertyIsEnumerable.
Event loop,event events loop even eventful eventually,Event loop is a mechanism that allows non-blocking execution af async code in a single threaded environment.
Web socket,socket websocket,WebSocket - event-driven protocol which means you can actually use it for truly realtime communication. Unlike HTTP where you have to constantly request updates with websockets updates are sent immediately when they are available. WebSockets keeps a single persistent connection open while eliminating latency problems that arise with HTTP request/response-based methods. WebSockets generally do not use XMLHttpRequest so headers are not sent every-time we need to get more information from the server. It reduces the expensive data loads being sent to the server.
Promise,promise,Promises are used to handle async operations. A promise is created using the Promise constructor which takes 2 callbacks as parameters: resolve and reject. Promise states: 1. pending - initial state (promise has neither been fulfilled nor been rejected) 2. fulfilled - async operation has accomplished 3. rejected - async operation has failed 4. settled - rejected or fulfilled
Client-side storages,starage storages,"Cookies, session storage, local storage, cache storage, indexed DB."
Service workers,service worker workers,SW allow the app to use cached resources first and provide default experience offline before getting more data from the network later. SW actively use promises. SW has to be installed activated and then it can react on fetch push and sync events. SW can't access the DOM directly. But it can communicate with the pages it controls by responding to messages sent via the 'postMessage' interface and those pages can manipulate the DOM.
GC algorithms,garbage collector,GC is a memory cleanup performed automatically - we cannot force or prevent it. 1. 'Reference count' - refs to object are being counted and if the their number is 0 then it's marked as collectible. Mem leak with circular refs thus modern browsers don't use it. 2. 'Mark-and-sweep' - improvement over previous one. Helps to define circular refs. Periodically tryies to reach all refs from so-called global root objects.Marks the object as collectible if it cannot be reached from the root one. Some of the optimizations: 'Generational collection' – objects are split into two sets: 'new ones' and 'old ones'. Many objects have a short life span: they appear do their job and die fast so it makes sense to track new objects and clear the memory from them if that's the case. Those that survive for long enough become 'old' and are examined less often. 'Incremental collection' – if there are many objects and we try to walk and mark the whole object set at once it may take some time and introduce visible delays in the execution. So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small GCs instead of a total one. That requires some extra bookkeeping between them to track changes but we get many tiny delays instead of a big one. 'Idle-time collection' – the garbage collector tries to run only while the CPU is idle to reduce the possible effect on the execution.
Weak collections,weak week,WeakSet - non-iterable collection that contains only objects and no other type. Set contains strong references to the objects whilst WeakSet contains weak references (GCed if no other references to a key object). WeakMap - non-iterable key/value collection whose keys must be objects without strong references (object's presence as a key in a WeakMap does not prevent the object from being GCed). WeakMap can be useful for mapping keys to values when it's valuable ONLY if the key has not been GCed. Since WeakMap doesn't allow observing the liveness of its keys it is not iterable.