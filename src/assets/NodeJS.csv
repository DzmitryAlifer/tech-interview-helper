topic,words,answer
NodeJS and its benefits,benefit benefits node nodejs,<i>NodeJS</i> - server-side runtime environment for developing client-server applications. It has built-in <i>events</i> and <i>event listeners</i>. NodeJS also provides functionality to create custom events and event listeners.<br><br>NodeJS is well suited for applications that have a lot of concurrent connections and each request only needs very few CPU cycles because the event loop is blocked during execution of a function.<br><br>NodeJS benefits:<br><br>1. <i>Aynchronous and Event Driven</i> - All API libraries are async (non-blocking). So Node.js server never waits for a API to return data. Server moves to next API after calling it and a notification mechanism of Events of Node.js helps server to get response from the previous API call.<br><br>2. <i>Very fast</i> - Node.js is built on V8 JS engine (uses inline caching). Node.js has a wrapper over the engine which is very fast in code execution.<br><br>3. <i>Single Threaded but highly scalable</i> - Node.js uses a single threaded model with event looping. So the same program can services much larger number of requests than traditional server like Apache HTTP Server.<br><br>4. <i>Reduced development time</i> - in comparison to Java takes much less time and codelines to deliver a new endpoint.
NodeJS work,node nodejs work works event eventful even loop,NodeJS works async in single-threaded environment by using the event loop and callback functions to handle multiple requests coming in parallel.<br><br><i>Event Loop</i> is a functionality which handles and processes all your external events and just converts them to a callback function. It invokes all the event handlers at a proper time. So that the new incoming request doesn't have to wait if the processing is not complete. While processing a request NodeJS attaches a callback function to it and moves it to the back-end. When its response is ready an event is called which triggers the associated callback function to send this response.
Concurrency,concurrency tread threaded,NodeJS provides a single thread. Internally it uses multiple POSIX threads for various I/O operations such as File or DNS or Network calls etc. When Node gets I/O request it creates or uses a thread to perform that I/O operation and once the operation is done it pushes the result to the event queue. On each such event; event loop runs and checks the queue and if the execution stack is empty then it adds the queue result to execution stack.
Global dependencies installation,global dependency dependencies installation,Globally installed packages/dependencies are stored in /npm directory. Such dependencies can be used in CLI but can not be imported using <i>require()</i> in Node application directly. To install a Node project globally use <i>-g</i> flag.
Global objects,global objects console process buffer,<i>Global objects</i> - available in all modules:<br>- <i>process</i> - provides info about and control over the current NodeJS process<br>- <i>console</i> - for printing to stdout and stderr<br>- <i>buffer</i> - for handling binary data
Error-first callback,error first fist callback,Error-first callbacks are used to pass errors and data. 1st argument is always an error object. Additional arguments are used to pass data.
Post request,post request,<pre>require('request').post(<br>    'http://www.example.com/action';<br>    {form: {key: 'value'}};<br>    function(error; response; body) {<br>        if (response.statusCode == 200) console.log(body);<br>});</pre>
Control flow function,control flow function,<i>Control flow function</i> - generic piece of code which runs in between several async function calls.
Event listener,event listener listener,<i>Event listener</i> - callback associated with some event.
Child process module,child external process processes,<i>Child process module</i> allows us to run external processes (operating system functionaries or other apps). So we can use <i>child processes</i> to run system command or to read large files without blocking or decompose app into various 'nodes'.<br><br>Ways to create child process:<br>- <i>child_process.spawn</i> - launches a new process with a given command<br>- <i>child_process.exec</i> - runs a command in a shell/console and buffers the output<br>- <i>child_process.fork</i> - special case of the <i>spawn()</i> to create child processes
Core modules,core module modules,<br>- <i>http</i> - classes methods and events to create NodeJS http server<br>- <i>url</i> - methods for URL resolution and parsing<br>- <i>querystring</i> - methods to deal with query strings (ecode decode escape stringify parse)<br>- <i>path</i> - path module includes methods to deal with file paths<br>- <i>fs</i> - classes methods and events to work with file system; all methods have <i>sync</i> and <i>async</i> forms<br>- <i>stream</i> - streaming API for working with stream consumers and stream implementers<br>- <i>util</i> - useful utility functions
REPL,REPL read eval print,<i>REPL (Read Eval Print Loop)<i> - represents the environment like console or shell where a command is entered and system responds with an output. Node comes bundled with a REPL environment. It performs the following tasks:<br><br><i>Read</i> - reads user input and parses it into JS data-structure and stores in memory<br><i>Eval</i> - evaluates the data structure<br><i>Print</i> - prints the result<br><i>Loop</i> - loops the above command until user press <i>ctrl-c twice</i>
Event emitter,event emitter,All objects that emit events are members of <i>EventEmitter</i> class. These objects expose <i>eventEmitter.on()</i> function that allows one or more functions to be attached to named events emitted by the object. When <i>EventEmitter</i> object emits an event all the attached functions are called <i>synchronously</i>.
Buffer class,buffer class,<i>Buffer class</i> - global class (can be accessed in application without importing its module) which is a kind of array of integers and corresponds to a raw memory allocation outside the V8 heap. <i>Buffer</i> cannot be resized.
Streams,stream streams,<i>Streams</i> - objects that let you read data from a source or write data to a destination continuously (with changes over time). In Node there are four types of streams:<br><i>readable</i> - for read operations<br><i>writable</i> - for write operations<br><i>duplex</i> - for read and write operations<br><i>transform</i> - type of <i>duplex</i> stream where output is computed based on input
Chaining,chaining,<i>Chanining</i> - mechanism to connect output of one stream to another stream and create a chain of multiple stream operations. It is normally used with piping operations.
Callback hell,callback call back hell,Async function requires callback as a return parameter. When multiple async functions are chained together then callback hell situation comes up.<br><br>Ways to avoid <i>callback hell</i>:<br>1. <i>Modularity</i> - split the logic into smaller modules.<br>2. <i>Async mechanism</i> - NodeJS module providing a sequential flow of execution (by means of methods <i>waterfall() map() series()</i>).<br>3. <i>Promises</i> - promises give a way to write seamless async code by means of their instanse (<i>then() catch()</i>) and static methods(<i>all() any() race()</i>). <br>4. <i>Generators (function* ())</i> - make a function wait and resume via the <i>yield</i> keyword. They can also suspend and resume <i>async</i> operations using constructs such as promises or and turn <i>sync</i> code into <i>async</i>.
Unhandled exceptions,unhandled exception exceptions,<i>Unhandled exceptions</i> in NodeJS can be caught at the <i>Process</i> level by attaching a handler for <i>uncaughtException</i> event:<br><i>process.on('uncaughtException'; function(err) {...}</i><br><br>However <i>uncaughtException</i> is a very crude mechanism for exception handling. An exception that has bubbled up to <i>Process</i> level means that your app might be in an undefined state and the only sensible approach would be to restart everything. The preferred way is to add another layer between your application and NodeJS process which is called <i>domain</i>. <i>Domains</i> provide a way to handle multiple different I/O operations as a single group. So by having your application or part of it running in a separate domain you can safely handle exceptions at the <i>domain</i> level before they reach the <i>Process</i> level.
Domain,domain,<i>Domains</i> provide a way to handle multiple different I/O operations as a single group. So by having your application or part of it running in a separate domain you can safely handle exceptions at the <i>domain</i> level before they reach the <i>Process</i> level.
Piping,piping pipe pipes,<i>Piping</i> - mechanism to connect output of one stream to another stream. It is normally used to get data from one stream and to pass output of that stream to another stream.